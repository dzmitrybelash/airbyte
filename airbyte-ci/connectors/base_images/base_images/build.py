#
# Copyright (c) 2023 Airbyte, Inc., all rights reserved.
#
import os
import shutil
import sys
from itertools import product
from pathlib import Path
from unittest.mock import MagicMock

import anyio
import dagger
from base_images import GLOBAL_REGISTRY, common, console, consts, errors, hacks, registries
from rich.status import Status

DOCKERFILE_HEADER = """
# This file is generated by base_images/build.py. Please do not edit it manually.
# It is not used by Airbyte internal build process.
# It is meant for documentation and debugging purposes.
"""

DOCKERFILES_DIRECTORY = Path(consts.PROJECT_DIR / "generated" / "dockerfiles")


def generate_dockerfile(dockerfile_directory: Path, base_image_version: common.AirbyteConnectorBaseImage):
    """
    Generates the dockerfiles for all the base images.
    """
    dockerfile = hacks.get_container_dockerfile(base_image_version.container)
    dockerfile_directory = dockerfile_directory / base_image_version.image_name / base_image_version.platform
    dockerfile_directory.mkdir(exist_ok=True, parents=True)
    dockerfile_path = Path(dockerfile_directory / f"{base_image_version.version}.Dockerfile")
    dockerfile = DOCKERFILE_HEADER + "\n" + dockerfile + "\n"
    dockerfile_path.write_text(dockerfile)
    console.log(
        f":whale2: Generated Dockerfile for {base_image_version.name_with_tag} for {base_image_version.platform}: {dockerfile_path}",
        highlight=False,
    )


async def run_sanity_checks(base_image_version: common.AirbyteConnectorBaseImage, registry: registries.VersionRegistry) -> bool:
    """
    Runs sanity checks on a base images.
    Sanity checks are declared in the base image version classes by implementing the run_sanity_checks function.
    Sanity checks are commands executed on the base image container, we check the output of these command to make sure the base image is working as expected.
    """
    try:
        await base_image_version.run_sanity_checks_for_version()
        console.log(
            f":white_check_mark: Successfully ran sanity checks on {base_image_version.name_with_tag} for {base_image_version.platform}",
            highlight=False,
        )
        if base_image_version.run_previous_version_sanity_checks:
            PreviousVersion = registry.get_previous_version(base_image_version)
            if PreviousVersion:
                await PreviousVersion.run_sanity_checks(base_image_version)
                console.log(
                    f":white_check_mark: Successfully ran sanity checks on previous version: {PreviousVersion.name_with_tag} for {base_image_version.platform}",
                    highlight=False,
                )
        return True
    except errors.SanityCheckError as sanity_check_error:
        console.log(
            f":cross_mark: Sanity checks failure on {base_image_version.name_with_tag} for {base_image_version.platform}: {sanity_check_error}",
            style="bold red",
            highlight=False,
        )
        return False


async def build_registry(dagger_client: dagger.Client, current_status: Status, registry: registries.VersionRegistry) -> bool:
    """Generate the dockerfiles, run the sanity checks and write the changelog for a registry.

    Args:
        dagger_client (dagger.Client): The dagger client.
        current_status (Status): The rich status object to update.
        registry (registries.VersionRegistry): The registry to build.

    Returns:
        bool: True if all the sanity checks passed, False otherwise.
    """
    sanity_check_successes = []
    for platform, BaseImageVersion in product(consts.SUPPORTED_PLATFORMS, registry.versions):
        base_image_version = BaseImageVersion(dagger_client, platform)
        current_status.update(f":whale2: Generating dockerfile for {base_image_version.name_with_tag} for {base_image_version.platform}")
        generate_dockerfile(DOCKERFILES_DIRECTORY, base_image_version)
        current_status.update(f":mag_right: Running sanity checks on {base_image_version.name_with_tag} for {base_image_version.platform}")
        success = await run_sanity_checks(base_image_version, registry)
        sanity_check_successes.append(success)
    fully_successful = all(sanity_check_successes)
    if fully_successful:
        console.log(f":tada: All sanity checks passed for {registry.base_image_name}", style="bold green")
        current_status.update(f"Writing the changelog for {registry.base_image_name}")
        changelog_path = registry.write_changelog()
        console.log(
            f":memo: Wrote the updated changelog for {registry.base_image_name} to {changelog_path}.",
        )
    else:
        console.log(f":bomb: Did not write the changelog: sanity checks failed for {registry.base_image_name}", style="bold red")
    return fully_successful


async def build(current_status: Status) -> bool:
    current_status.update(":dagger: Initializing Dagger")
    if consts.DEBUG:
        dagger_config = dagger.Config(log_output=sys.stderr)
    else:
        dagger_logs_path = Path("/tmp/base_images_project_build_dagger_logs.log")
        dagger_logs_path.unlink(missing_ok=True)
        dagger_logs_path.touch()
        dagger_config = dagger.Config(log_output=open(dagger_logs_path, "w"))
        console.log(f":information_source: Dagger logs will be written to {dagger_logs_path}")
    build_successes = []

    # Clear the generated dockerfiles directory, we will regenerate them.
    shutil.rmtree(DOCKERFILES_DIRECTORY, ignore_errors=True)

    async with dagger.Connection(dagger_config) as dagger_client:
        for registry in GLOBAL_REGISTRY.all_registries:
            build_successes.append(await build_registry(dagger_client, current_status, registry))
    return all(build_successes)


def main():
    """
    This function is called by the build command, currently via poetry run build.
    It's currently meant to be run locally by developers to generate the changelog and run sanity checks.
    It can eventually be run in CI to generate the changelog and run sanity checks.

    1. Run sanity checks on all the base images.
    2. Write the changelog for the python base image.

    This function calls Dagger to run the sanity checks.
    If you don't have the base base image locally it will be pulled, which can take a while.
    Subsequent runs will be faster as the base images layers and sanity checks layers will be cached locally.
    """
    try:
        default_build_status = console.status("Building the project", spinner="bouncingBall")
        disabled_build_status = MagicMock(default_build_status)
        build_status = default_build_status if not consts.DEBUG else disabled_build_status
        with build_status as current_status:  # type: ignore
            global_build_success = anyio.run(build, current_status)
            if not global_build_success:
                console.log(
                    ":bomb: Build failed. Feel free to prepend the command with LOG_LEVEL=DEBUG if you want to investigate Dagger logs.",
                    style="bold red",
                )
            else:
                if os.getenv("GIT_HOOK"):
                    console.log("[bold green] The updated changelog and dockerfile files were commited.[/bold green]")
                else:
                    console.log("[bold green]You can now commit and push the changelog and the generated dockerfiles![/bold green]")
            if not global_build_success:
                sys.exit(1)
    except KeyboardInterrupt:
        console.log(":bomb: User aborted the build.", style="bold red")
        sys.exit(1)


if __name__ == "__main__":
    main()
